### 1. GCC
일단, C 프로그래밍을 하려면 컴파일러가 있어야 되는데, 아시다 시피 리눅스 상에서는 Visual Studio 계열을 사용할 수 없습니다. 왜냐하면 그것들은 모두 Microsoft 사의 제품이기 때문이죠. 하지만, 훌륭한 오픈 소스 개발자들이 리눅스 용 컴파일러를 개발하였는데, 그 이름하여 유명한 GCC (GNU Compiler Collection) 입니다. 사실, 초기의 GCC 는 GNU C Compiler 의 약자로, C 언어 컴파일만 지원하였으나, 후에 Ada, C++, JAVA, Fotran, Objective-C 와 같은 언어들도 컴파일 할 수 있게 되여 현재의 이름으로 바뀌었습니다.

대부분의 우분투 배포판에는 기본적으로 GCC 가 설치되어 있습니다. 

- 컴파일만 하기: gcc source.c와 같이 소스 코드 파일을 지정하여 컴파일할 수 있습니다. 이렇게 하면 기본적으로 a.out과 같은 실행 파일이 생성됩니다.

- 실행 파일 이름 변경: -o 옵션을 사용하여 생성된 실행 파일의 이름을 지정할 수 있습니다. 예를 들어, gcc source.c -o program은 source.c 파일을 컴파일하고 program이라는 실행 파일을 생성합니다.

- 다수의 소스 파일 컴파일: 여러 소스 파일을 한 번에 컴파일할 수 있습니다. 예를 들어, gcc file1.c file2.c -o program은 file1.c 및 file2.c를 컴파일하고 program이라는 실행 파일을 생성합니다.

- 헤더 파일 및 라이브러리 포함: -I 옵션을 사용하여 특정 디렉토리에 있는 헤더 파일을 포함할 수 있습니다. -L 옵션을 사용하여 특정 디렉토리에서 라이브러리 파일을 찾을 수 있습니다.

- 컴파일러 옵션 지정: 다양한 컴파일러 옵션을 사용하여 컴파일 동작을 제어할 수 있습니다. 예를 들어, -Wall 옵션은 모든 경고를 출력하도록 설정하고, -std 옵션은 사용할 C 언어 표준을 지정합니다.

-------------------------------------------------------
### 2. Makefile
Makefile은 소프트웨어 프로젝트의 빌드 프로세스를 자동화하기 위해 사용되는 텍스트 파일입니다. 일반적으로 소스 코드 파일, 헤더 파일 및 기타 리소스 파일의 컴파일 및 링크 프로세스를 정의하는 데 사용됩니다. Makefile은 make 도구에 의해 읽혀지며, 프로젝트를 빌드하기 위한 컴파일 및 링크 단계를 결정하는 규칙과 명령어를 제공합니다.

Makefile은 다음과 같은 요소로 구성됩니다:
타겟(Target): 빌드할 대상 파일의 이름입니다. 일반적으로 실행 파일, 라이브러리 또는 특정 작업을 나타냅니다.
의존성(Dependency): 타겟을 빌드하기 위해 필요한 다른 파일 또는 리소스입니다. 의존성은 다른 파일의 변경 사항에 따라 결정됩니다.
명령어(Command): 타겟을 빌드하는 데 사용되는 명령어입니다. 주로 컴파일러 및 링커 명령이 여기에 포함됩니다.
예를 들어, C 프로젝트의 Makefile은 다음과 같이 정의될 수 있습니다:

```
# 빌드 대상 및 의존성 정의
program: main.o helper.o
    gcc -o program main.o helper.o

main.o: main.c helper.h
    gcc -c main.c

helper.o: helper.c helper.h
    gcc -c helper.c

# clean 명령어 정의
clean:
    rm -f program *.o
```
위의 Makefile은 main.c와 helper.c라는 소스 파일과 그에 해당하는 헤더 파일을 컴파일하여 program이라는 실행 파일을 빌드합니다. 또한 clean이라는 명령어를 정의하여 컴파일된 파일을 정리할 수 있습니다. 이제 make 명령을 사용하여 프로젝트를 빌드하고 make clean 명령을 사용하여 컴파일된 파일을 정리할 수 있습니다. Makefile은 프로젝트의 구조와 요구 사항에 따라 수정될 수 있습니다.

-------------------------------------------------------
### 3. 2의 보수
여러분이 CPU 개발자라면 컴퓨터 상에서 정수 음수를 어떤식으로 표현하도록 만들었을까요? 가장 간단히 생각해보자면 우리가 부호를 통해서 음수 인지 양수 인지 나타내니까, 비슷한 방법으로 부호를 나타내기 위해서 1 비트를 사용하는 것입니다.
이는 0을 2가지로 표현하게 되는 치명적인 문제가 있다.
0 을 표현하는 방법이 두 가지라면, 어떠한 데이터가 0 인지 확인하기 위해서 +0 인지 -0 인지 두 번이나 확인해야 하게 됩니다. 따라서 이상한 데이터 표현법 덕분에 쓸데없이 컴퓨터 자원을 낭비하게 됩니다.

물론 부호 비트를 도입해서 음수와 양수를 구분하는 아이디어 자체는 나쁜 생각은 아닙니다. 여기서는 int 와 같은 정수 데이터만 다루지만 double 이나 float 처럼 소수인 데이터를 다루는 방식에서는 (이를 부동 소수점 표현 이라고 하는데, 나중 강좌에서 자세히 알아봅시다.) 부호 비트를 도입하여서 음수인지 양수인지를 표현하고 있습니다.
실제로 부동 소수점 표현법에서는 -0 과 +0 이 있습니다.

-------------------------------------------------------
### IEEE 754 부동 소수점




-------------------------------------------------------
```
#include <stdio.h>
int main() {
  int arr[] = {1,2,3,4,5,6,7,8,9};
  int **parr = arr;
  int *parr2 = arr;

  printf("%p \n", arr); // 실행 결과: 0x7ffecd27fbe0
  printf("%p \n", parr+1); // 실행 결과: 0x7ffecd27fbe8
  printf("%p \n", parr2+1); // 실행 결과: 0x7ffecd27fbe4

  return 0;
}
```

```
#include <stdio.h>
int main() {
  int arr[] = {1,2,3,4,5,6,7,8,9};
  int **parr = arr;
  int (*parr2)[9] = arr;

  printf("%p \n", arr); // 실행 결과: 0x7ffd8b755110
  printf("%p \n", parr+1); // 실행 결과: 0x7ffd8b755118
  printf("%p \n", parr2+1); // 실행 결과: 0x7ffd8b755134

  return 0;
}
```
```
#include <stdio.h>
int main() {
  int arr[] = {1,2,3,4,5,6,7,8,9};
  int *(*parr) = arr;
  int (*parr2)[9] = arr;

  printf("%p \n", arr); // 실행 결과: 0x7ffd8b755110
  printf("%p \n", parr+1); // 실행 결과: 0x7ffd8b755118
  printf("%p \n", parr2[1]); // 실행 결과: 0x7ffd8b755134

  return 0;
}
```
-------------------------------------------------------
C 언어 상에서 배열의 이름이 sizeof 연산자나 주소값 연산자(&)와 사용될 때 (예를 들어 &arr) 경우를 빼면, 배열의 이름을 사용시 암묵적으로 첫 번째 원소를 가리키는 포인터로 타입 변환되기 때문입니다.



-------------------------------------------------------
어떠한 함수가 특정한 타입의 변수/배열의 값을 바꾸려면 함수의 인자는 반드시 그 타입을 가리키는 포인터를 이용해야 한다!

Call by value(값에 의한 호출):

함수에 전달되는 인자의 값이 복사되어 함수 내부로 전달됩니다.
따라서 함수 내부에서 해당 인자의 값을 변경해도 호출자에게는 영향을 주지 않습니다.
C 언어에서 기본적으로 사용되는 방식입니다.
Call by reference(참조에 의한 호출):

함수에 전달되는 인자의 주소(참조)가 전달되어 함수 내부로 전달됩니다.
따라서 함수 내부에서 해당 인자를 변경하면 호출자에게도 변경된 값이 반영됩니다.
포인터를 사용하여 구현되며, 포인터를 통해 실제 변수에 접근하여 값을 변경합니다.

포인터의 포인터 주소를 넣어서 값변경도 쌉가능 (이 부분 명쾌하게 설명할 줄 알아야 한다)

-------------------------------------------------------
typedef는 C 언어에서 사용되는 키워드로, 새로운 자료형에 대한 별칭을 정의하는 데 사용됩니다. 이를 통해 코드를 더 읽기 쉽고 이해하기 쉽게 만들 수 있습니다.

일반적으로 typedef는 기존의 자료형에 새로운 이름을 부여하는 데 사용됩니다. 이렇게 정의된 별칭은 프로그램의 다른 부분에서 자료형을 사용할 때 원래의 자료형 이름 대신에 사용됩니다.

예를 들어, 다음과 같이 typedef를 사용하여 새로운 이름을 부여할 수 있습니다:

typedef int MY_INT;
위 예제는 int 자료형에 MY_INT라는 새로운 이름을 부여합니다. 이제 프로그램의 다른 부분에서 MY_INT를 사용하여 int 자료형을 대신할 수 있습니다.

MY_INT num = 10;
typedef는 복잡한 자료형이나 함수 포인터 등을 간결하고 읽기 쉽게 정의하는 데에도 사용됩니다. 이를 통해 코드의 가독성을 높이고 오류를 줄일 수 있습니다.

-------------------------------------------------------
C 프로그래밍에서 "센티넬(sentinel)"은 특정한 값이나 패턴을 의미적으로 사용하는 것을 말합니다. 주로 데이터의 끝을 나타내는 데에 사용되며, 배열이나 문자열과 같은 데이터 구조에서 종료 조건을 나타내는 데 유용합니다.

가장 흔한 예로는 문자열에서 널 종료 문자(\0)를 사용하는 것이 있습니다. C 언어에서 문자열은 널 종료 문자로 끝나야 하며, 따라서 문자열의 끝을 나타내는데 센티넬로 사용됩니다.

또 다른 예로는 배열의 끝을 나타내는 데에 사용될 수 있습니다. 예를 들어, 정수 배열의 끝을 나타내기 위해 -1을 센티넬로 사용할 수 있습니다. 배열의 끝까지 반복하는 반복문에서 센티넬을 만나면 반복을 종료할 수 있습니다.

센티넬은 데이터 구조에서 종료 조건을 나타내는 데 유용하지만, 센티넬 값 자체는 실제 데이터와 구별되도록 주의해야 합니다. 따라서 센티넬 값을 실제 데이터로 사용할 때는 반드시 데이터와 중복되지 않는 값을 선택해야 합니다.

-------------------------------------------------------
함수의 원형(prototype)

소스 코드의 제일 윗부분을 보면 위와 같이 한 줄이 추가된 것을 볼 수 있습니다. 이는 바로 '함수의 원형' 이라 부르는 것입니다. 이는 사실 함수의 정의 부분을 한 번 더 써준 것 뿐입니다 (주의할 점은 함수의 원형에는 정의와는 달리 뒤에 ; 를 붙인 다는 것입니다). 그런데, 이 한줄이 컴파일러에게 다음과 같은 사실을 알려줍니다.

야, 이 소스코드에 이러 이러한 함수가 정의되어 있으니까 잘 살펴봐
다시말해, 컴파일러에게 이 소스코드에 사용되는 함수에 대한 정보를 제공하는 것입니다. 다시 말해 실제 프로그램에는 전혀 반영되지 않는 정보지요. 그렇지만, 우리가 앞서 하였던 실수들을 하지 않도록 도와줍니다. 만일, 위와 같이 함수의 원형을 삽입한 상태에서 인자를 &i 하나로 지워 봅시다. 즉, swap(&i, &j) 를 swap(&i); 로 변경해봅시다.

그럼 컴파일 시 아래와 같은 오류를 만나게 됩니다.

컴파일 오류

 error C2198: 'swap' : 호출에 매개 변수가 너무 적습니다.

-------------------------------------------------------
Sentinel 노드는 자료 구조에서 사용되는 특수한 노드로, 주로 경계를 표시하거나 특정 조건을 나타내는 데 사용됩니다. 이것은 일반적으로 사용자가 데이터로 추가하거나 검색하지 않는 노드입니다. 대신, 알고리즘이나 자료 구조의 특정 기능을 지원하기 위해 삽입됩니다.

Sentinel 노드의 주요 용도는 빈 리스트를 나타내는 데 사용되며, 이는 특히 이중 연결 리스트나 트리 구조에서 유용합니다. 이러한 자료 구조에서는 빈 리스트를 나타내기 위해 NULL 포인터를 사용할 수 있지만, 이는 코드를 복잡하게 만들 수 있습니다. 따라서 Sentinel 노드를 사용하여 빈 리스트를 나타내는 것이 더 간단하고 일관성 있습니다.

예를 들어, 이진 탐색 트리에서 빈 트리를 나타내기 위해 하나의 Sentinel 노드를 사용할 수 있습니다. 이 노드는 실제 데이터를 가지지 않고, 트리의 루트 노드가 NULL일 때 Sentinel 노드를 가리키게 됩니다. 이렇게 함으로써 트리의 빈 상태를 쉽게 확인할 수 있습니다.

Sentinel 노드는 특정 조건을 나타내는 데도 사용될 수 있습니다. 예를 들어, 이중 연결 리스트에서의 첫 번째 노드를 가리키는 Sentinel 노드를 사용하여 특별한 조건을 나타낼 수 있습니다. 이러한 노드는 헤드 노드로부터의 이전 노드를 가리키며, 헤드 노드가 첫 번째 노드일 때 Sentinel 노드를 가리키게 됩니다. 이를 통해 리스트의 시작과 끝을 구별할 수 있습니다.

-------------------------------------------------------
여기서 <executable>은 실행할 목적 파일의 경로입니다.
gdb <executable>

특정 줄에 중단점을 설정하려면 다음과 같이 gdb 내에서 해당 줄 번호를 지정합니다:
break <line_number>

특정 함수 내에서 중단점을 설정하려면 다음과 같이 gdb 내에서 함수 이름을 지정합니다:
break <function_name>

또는 특정 파일에서 모든 함수에 중단점을 설정하려면 다음과 같이 gdb 내에서 파일 이름을 지정합니다:
break <file_name>:<line_number>

설정한 중단점을 포함하여 gdb에서 프로그램을 실행합니다.
run

프로그램이 중지된 후에는 gdb 프롬프트에서 변수나 포인터의 주소를 확인할 수 있습니다. 이전 답변에서 설명한대로 print 명령어를 사용하여 주소를 확인할 수 있습니다.
중지된 상태에서 변수나 포인터의 값을 확인하기 위해 print 명령어를 사용할 수 있습니다. 예를 들어, 변수 x의 주소를 확인하려면 다음과 같이 입력합니다:
print &x
print ptr

프로그램이 실행되면 x 명령어를 사용하여 메모리를 확인할 수 있습니다. 일반적인 사용법은 다음과 같습니다:
x/<표시 형식> <주소>
x/12x 0x5555555592a0

-------------------------------------------------------
Makefile에서 모든 타겟들 따로 실행 가능함
아래와 같은 makefile이 있으면
make clean, make driver, make driver.o, make rbtree.o 모두 행된다.
.PHONY는 파일이 아닌 명령어라고 명시해놓는 것일 뿐이다. 

.PHONY: clean

CFLAGS=-Wall -g

driver: driver.o rbtree.o
		cc driver.o rbtree.o -o driver

driver.o: rbtree.h driver.c
		cc $(CFLAGS) -c driver.c -o driver.o

rbtree.o: rbtree.h rbtree.c
		cc $(CFLAGS) -c rbtree.c -o rbtree.o

clean:
	rm -f driver *.o

-------------------------------------------------------
https://modoocode.com/311 
그런데, 만약에 실제로 clean 이라는 파일이 디렉토리에 생성된다면 어떨까요? 우리가 make clean 을 하게 되면, make 는 clean 의 필요 파일들이 없는데, clean 파일이 있으니까 clean 파일은 항상 최신이네? recipe 를 실행 안해도 되겠네! 하면서 그냥 make clean 명령을 무시해버리게 됩니다.

$ ls clean
clean
$ make clean
make: 'clean' is up to date.
실제로 디렉토리에 clean 이라는 파일을 만들어놓고 실행해보면 위와 같이 이미 clean 은 최신이라며 recipe 실행을 거부합니다.

이와 같은 상황을 막기 위해서는 clean 을 PHONY 라고 등록하면 됩니다.


-------------------------------------------------------
CFLAGS를 쓰면 알아서 명령어에 넣어준다.
CFLAGS=-Wall -g
make -C src
make: Entering directory '/home/ubuntu/CWorkspace/rbtree-lab/src'
cc -Wall -g   -c -o driver.o driver.c
cc -Wall -g   -c -o rbtree.o rbtree.c
cc   driver.o rbtree.o   -o driver
make: Leaving directory '/home/ubuntu/CWorkspace/rbtree-lab/src'



안 넣어주면 아래와 같다.
make -C src
make: Entering directory '/home/ubuntu/CWorkspace/rbtree-lab/src'
cc    -c -o driver.o driver.c
cc    -c -o rbtree.o rbtree.c
cc   driver.o rbtree.o   -o driver
make: Leaving directory '/home/ubuntu/CWorkspace/rbtree-lab/src'


-------------------------------------------------------
우분투 리눅스에서 commit --amend하면 cli에서 수정이 이루어지는데,
gnu nano 6.2버전을 쓴다고 한다. 정확히 뭔지는 모르겠다.
우선 저장은 ctrl + o 이고 enter을 누르고 ctrl + x누르면 종료된다.

-------------------------------------------------------
launch.json에서 program에 실행파일을 넣어주면 해당 파일 디버깅 가능

    "configurations": [
        {
            "name": "(gdb) 시작",
            "type": "cppdbg",
            "request": "launch",
            "program": "/home/ubuntu/CWorkspace/rbtree-lab/src/test-bst",

-------------------------------------------------------
이진검색트리 삭제
https://velog.io/@keum0821/%EC%9D%B4%EC%A7%84-%ED%83%90%EC%83%89-%ED%8A%B8%EB%A6%ACBinary-Search-Tree-%EA%B5%AC%ED%98%84-%EC%82%AD%EC%A0%9C

-------------------------------------------------------
일반적으로 이진 탐색 트리(Binary Search Tree, BST)는 중복 값을 허용하지 않습니다. 각 노드는 트리 내에서 고유한 값을 가지며, 중복된 값이 삽입될 경우 해당 값은 이미 존재하는 것으로 간주되고, 새로운 노드로 추가되지 않습니다. 따라서 동일한 값을 여러 번 삽입할 수 없습니다.

만약 중복 값을 허용하려면, 이진 탐색 트리의 구현을 변경하여 중복 값을 허용하는 방식으로 조정해야 합니다. 이를 위해서는 각 노드가 중복된 값을 가질 수 있도록 노드의 구조를 수정해야 합니다. 예를 들어, 각 노드에 연결 리스트 혹은 배열을 사용하여 중복된 값을 저장하고 관리할 수 있습니다. 그러나 이렇게 변경하면 탐색 및 삽입 연산의 복잡성이 증가할 수 있으며, 중복 값을 효율적으로 관리해야 합니다.

-------------------------------------------------------
이렇게 구조체가 있어.
이 구조체를 calloc으로 선언했어 그러면 root랑 nil 멤버변수는 NULL이야?
typedef struct {
  node_t *root;
  #ifdef SENTINEL
    node_t *nil;  // for sentinel
  #else
  
  #endif 
} rbtree;

    rbtree *p = (rbtree *)calloc(1, sizeof(rbtree));

ChatGPT
네, calloc 함수로 할당된 메모리는 모든 비트가 0으로 초기화됩니다. 따라서 root와 nil 멤버 변수는 NULL 포인터로 초기화됩니다. 이는 메모리 할당 후 구조체를 사용하기 전에 해당 멤버 변수를 초기화할 필요가 없다는 것을 의미합니다.

-------------------------------------------------------

C 언어에서 포인터를 선언하고 초기화하지 않으면, 그 포인터는 쓰레기 값(garbage value)을 가지게 됩니다. 이것은 메모리의 이전 내용에 따라 달라질 수 있습니다.

만약 포인터를 선언하고 초기화하지 않았을 때 해당 포인터를 사용하면, 그 포인터가 가리키는 메모리 주소는 예측할 수 없는 값이 됩니다. 이것은 프로그램이 비정상적인 동작을 할 수 있도록 만들 수 있습니다.

일반적으로 포인터를 사용하기 전에는 초기화하는 것이 좋습니다. 초기화되지 않은 포인터를 사용할 때 발생하는 문제를 피하기 위해서입니다. 초기화되지 않은 포인터를 사용하지 않도록 주의해야 합니다.